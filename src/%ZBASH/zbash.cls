Include %ZPM.PackageManager.Common

/// Used for version check
Class %ZBASH.zbash
{

ClassMethod Shell(pArgs)
{
    Set cmd = ""
    If $$$isMACOSX {
      Set cmd = "/bin/zsh -c "_ " """ _ pArgs _ """ 2>&1"
    }
    If $$$isUNIX {
      Set cmd = "/bin/bash -c"_ " """ _ pArgs _ """ 2>&1"
    }
    If $$$isWINDOWS {
      // IF WSL
      Set findWSL = ..CPIPESilent("cmd.exe /c WHERE wsl")
      Set isWSL = $MATCH(findWSL, ".*wsl.exe")
      IF isWSL {
        Set cmd = "wsl -- /bin/bash -c"_ " """ _ pArgs _ """ 2>&1"
        // ELSE use powershell
      } ELSE {
        Set cmd = "powershell /c "_ " """ _ pArgs _ """ 2>&1"
      }
    }
    IF $$$isVMS {
      Write "VMS is untested, quitting command output"
      QUIT
    }
    Set cmd = cmd _ " """ _ pArgs _ " "" 2>&1"
    #; WRITE cmd, !
    Do cmd^Zpipe(cmd)
}

ClassMethod CPIPESilent(command) As %String
{

    Set sc = $$$OK

    Set oldIO = $IO

    Set pResponse = ""

    Set dev="|CPIPE|1"

    Set $ZTRAP="cls"

    Set empty=0

    Set ncmd = command

    Open dev:ncmd:0

    write:0 $test,!

    Else  w "pipe failed" Quit 0

    While empty<3 {

        Use dev Read line 

        Set empty=$SELECT($LENGTH(line):0,1:$INCREMENT(empty))

        Set pResponse = pResponse _ line  ;;; or do any kind of analysis of the line 

        }

    Use oldIO
    #; $$$LOGINFO($ZUTIL(214))

cls ;

    Set $ZTRAP="" Use oldIO

    Close dev 

    If $ZERROR'["<ENDOFFILE>" Write $ZERROR,!

    Quit pResponse
}

ClassMethod UpdateLanguageExtensionsOne(RoutineName As %String, pTestOnly As %Boolean = 0, Output pFound As %Boolean = 0, ByRef tGenLines) As %Status
{
	#def1arg STARTTAGQ " ;Generated by %ZBASH.zpip: Start"
	#def1arg ENDTAGQ " ;Generated by %ZBASH.zpip: End"
	#def1arg STARTTAG ##Expression($$$STARTTAGQ)
	#def1arg ENDTAG ##Expression($$$ENDTAGQ)
	Set tRtn = ##class(%Routine).%New(RoutineName)
	If ##class(%Routine).Exists(RoutineName) {
    Set tEnded = 1
    While 'tRtn.AtEnd {
      Set tLine = tRtn.ReadLine()
      If (tLine = $$$STARTTAGQ) {
        // Read through the ending tag.
        While ('tRtn.AtEnd) && (tRtn.ReadLine() '= $$$ENDTAGQ) {}
        
        // Generate the lines.
        Set pFound = 1
        For i=1:1:tGenLines {
          Set tRtnLines($INCREMENT(tRtnLines)) = tGenLines(i)
        }
      } Else {
        // Before %ZLANGC00 was generated: there's an old version with ZPM defined.
        Set tIsZPM = ($ZCONVERT($EXTRACT(tLine,1,4),"U") = "ZPIP(")
        If tIsZPM {
          Set pFound = 1
          Set tEnded = 0
          Set tRtnLines($INCREMENT(tRtnLines)) = $$$STARTTAGQ
        }
        If '(tIsZPM || tEnded) {
          If ($ZSTRIP($EXTRACT(tLine),"*W") '= "") {
            Set tRtnLines($INCREMENT(tRtnLines)) = $$$ENDTAGQ
            Set tEnded = 1
          }
        }
        Set tRtnLines($INCREMENT(tRtnLines)) = tLine
      }
    }
    If 'tEnded {
      Set tRtnLines($INCREMENT(tRtnLines)) = $$$ENDTAGQ
    } ElseIf 'pFound {
      For i=1:1:tGenLines {
        Set tRtnLines($INCREMENT(tRtnLines)) = tGenLines(i)
      }
    }
  } Else {
    Merge tRtnLines = tGenLines
  }
  If (pTestOnly) {
    Quit
  }
  Do tRtn.Clear()
  For i=1:1:tRtnLines {
    Do tRtn.WriteLine(tRtnLines(i))
  }
  $$$ThrowOnError(tRtn.Save())
  $$$ThrowOnError(tRtn.Compile("/keepsource"))
	Quit $$$OK
}

ClassMethod UpdateLanguageExtensions(pVerbose As %Boolean = 0, pTestOnly As %Boolean = 0, Output pFound As %Boolean = 0) As %Status
{
	#def1arg STARTTAGQ " ;Generated by %ZBASH.zpip: Start"
	#def1arg ENDTAGQ " ;Generated by %ZBASH.zpip: End"
	#def1arg STARTTAG ##Expression($$$STARTTAGQ)
	#def1arg ENDTAG ##Expression($$$ENDTAGQ)

	Set tSC = $$$OK
	Set tInitTLevel = $TLEVEL
	Try {
		Tstart
		// Get routine lines to generate
		Set tOffset = 0
		Set tStarted = 0
		For {
			Set tLineName = "zUpdateLanguageExtensions"_"+"_$INCREMENT(tOffset)_"^"_$ZNAME
			Set tExtLine = $TEXT(@(tLineName))
			If (tExtLine=$$$STARTTAGQ) {
				Set tStarted = 1
			}
			If (tStarted) {
				Set tGenLines($INCREMENT(tGenLines)) = tExtLine
			}
			Quit:(tExtLine=$$$ENDTAGQ)
			Quit:(tExtLine="")
		}

		If '$DATA(tGenLines) {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Could not find %ZLANGC00 routine contents in "_$CLASSNAME()))
		}
		Do ..UpdateLanguageExtensionsOne("%ZLANGC00.MAC", pTestOnly,.pFound,.tGenLines)
		Quit:pTestOnly
		Set i="" 
		For { Set i=$ORDER(tGenLines(i),1,tStr) Quit:i=""
			If tStr[" Do ##class" Set tGenLines(i)=$REPLACE($REPLACE(tStr," Quit","")," Do "," Quit ") Quit
		}
		Do ..UpdateLanguageExtensionsOne("%ZLANGF00.MAC", pTestOnly,.pFound,.tGenLines)
		Tcommit
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLEVEL > tInitTLevel) {
		Trollback 1
	}
	Quit tSC
#; These are the actual contents of %ZLANGC00 (to be added/updated)
$$$STARTTAG
ZBASH(pArgs) Do ##class(%ZBASH.zbash).Shell(pArgs) Quit
$$$ENDTAG
#; Need an extra line down here to avoid the end bracket being on the same line as $$$ENDTAG - a comment is just fine.
}

ClassMethod PrintMessage()
{
  Write !
  Write !, "          _____                    _____                    _____                    _____                    _____          "
  Write !, "         /\    \                  /\    \                  /\    \                  /\    \                  /\    \         "
  Write !, "        /::\    \                /::\    \                /::\    \                /::\    \                /::\____\        "
  Write !, "        \:::\    \              /::::\    \              /::::\    \              /::::\    \              /:::/    /        "
  Write !, "         \:::\    \            /::::::\    \            /::::::\    \            /::::::\    \            /:::/    /         "
  Write !, "          \:::\    \          /:::/\:::\    \          /:::/\:::\    \          /:::/\:::\    \          /:::/    /          "
  Write !, "           \:::\    \        /:::/__\:::\    \        /:::/__\:::\    \        /:::/__\:::\    \        /:::/____/           "
  Write !, "            \:::\    \      /::::\   \:::\    \      /::::\   \:::\    \       \:::\   \:::\    \      /::::\    \           "
  Write !, "             \:::\    \    /::::::\   \:::\    \    /::::::\   \:::\    \    ___\:::\   \:::\    \    /::::::\    \   _____  "
  Write !, "              \:::\    \  /:::/\:::\   \:::\ ___\  /:::/\:::\   \:::\    \  /\   \:::\   \:::\    \  /:::/\:::\    \ /\    \ "
  Write !, "_______________\:::\____\/:::/__\:::\   \:::|    |/:::/  \:::\   \:::\____\/::\   \:::\   \:::\____\/:::/  \:::\    /::\____\"
  Write !, "\::::::::::::::::::/    /\:::\   \:::\  /:::|____|\::/    \:::\  /:::/    /\:::\   \:::\   \::/    /\::/    \:::\  /:::/    /"
  Write !, " \::::::::::::::::/____/  \:::\   \:::\/:::/    /  \/____/ \:::\/:::/    /  \:::\   \:::\   \/____/  \/____/ \:::\/:::/    / "
  Write !, "  \:::\~~~~\~~~~~~         \:::\   \::::::/    /            \::::::/    /    \:::\   \:::\    \               \::::::/    /  "
  Write !, "   \:::\    \               \:::\   \::::/    /              \::::/    /      \:::\   \:::\____\               \::::/    /   "
  Write !, "    \:::\    \               \:::\  /:::/    /               /:::/    /        \:::\  /:::/    /               /:::/    /    "
  Write !, "     \:::\    \               \:::\/:::/    /               /:::/    /          \:::\/:::/    /               /:::/    /     "
  Write !, "      \:::\    \               \::::::/    /               /:::/    /            \::::::/    /               /:::/    /      "
  Write !, "       \:::\____\               \::::/    /               /:::/    /              \::::/    /               /:::/    /       "
  Write !, "        \::/    /                \::/____/                \::/    /                \::/    /                \::/    /        "
  Write !, "         \/____/                  ~~                       \/____/                  \/____/                  \/____/         "
  Write !, "                                                                                                                             "
  Write !, ""
  Write !, "Welcome to the zbash help page!"
  Write !, ""
  Write !, "zbash is a command shortcut that allows you to execute a command in a Bash shell without having to manually enter the shell. This can be useful if you need to quickly execute a command or if you prefer to work in a Bash environment."
  Write !, ""
  Write !, "Usage:"
  Write !, "zbash ""[command]"""
  Write !, ""
  Write !, "Examples:"
  Write !, ""
  Write !, "    zbash ""ls"" : Execute the ls command in a Bash shell"
  Write !, "    zbash ""python script.py"" : Execute a Python script in a Bash shell"
  Write !, "    zbash ""cd /path/to/directory && python script.py"" : Change the current working directory in a Bash shell"
  Write !, ""
  Write !, "Notes:"
  Write !, ""
  Write !, "    The zbash command will automatically start a new Bash shell for each invocation."
  Write !, "    zbash does not support user input. There is no need to exit the command."
  Write !, ""
  Write !, "I hope this information helps you use zbash effectively. If you have any further questions or concerns, please consult the Bash documentation."
  Write !,!
}

}
